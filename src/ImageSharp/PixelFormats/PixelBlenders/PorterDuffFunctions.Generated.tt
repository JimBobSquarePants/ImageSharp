<#
// Copyright (c) Six Labors and contributors.
// Licensed under the Apache License, Version 2.0.
#>
<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// Copyright (c) Six Labors and contributors.
// Licensed under the Apache License, Version 2.0.

// <auto-generated />

using System;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace SixLabors.ImageSharp.PixelFormats.PixelBlenders
{
    internal static partial class PorterDuffFunctions
    {


<# void GenerateVectorCompositor(string name, string sourceVar, string destVar, string blendVar)
    {
        int a_s = sourceVar == "Vector4.Zero" ? 0 : 1;
        int a_b = destVar == "Vector4.Zero" ? 0 : 1;
        int a_x = blendVar == "Vector4.Zero" ? 0 : 1;
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=name#>(Vector4 backdrop, Vector4 source, Vector4 xform)
        {
            // calculate weights
            float xw = backdrop.W * source.W;
            float bw = backdrop.W - xw;
            float sw = source.W - xw;

            // calculate final alpha
            float fw = (sw * <#=a_s#>) + (bw * <#=a_b#>) + (xw * <#=a_x#>);

            // calculate final value
            xform = ((<#=blendVar#> * xw) + (<#=destVar#> * bw) + (<#=sourceVar#> * sw)) / MathF.Max(fw, Constants.Epsilon);
            xform.W = fw;

            return xform;
        }
<# } #>





<# void GeneratePixelBlenders(string blender) { #>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_Src(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return Src(backdrop, source, <#=blender#>(backdrop, source));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_SrcAtop(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return SrcAtop(backdrop, source, <#=blender#>(backdrop, source));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_SrcOver(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return SrcOver(backdrop, source, <#=blender#>(backdrop, source));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_SrcIn(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return SrcIn(backdrop, source, <#=blender#>(backdrop, source));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_SrcOut(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return SrcOut(backdrop, source, <#=blender#>(backdrop, source));
        }

       [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_Dest(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return Dest(backdrop, source, <#=blender#>(backdrop, source));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_DestAtop(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return DestAtop(backdrop, source, <#=blender#>(backdrop, source));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_DestOver(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return DestOver(backdrop, source, <#=blender#>(backdrop, source));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_DestIn(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return DestIn(backdrop, source, <#=blender#>(backdrop, source));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_DestOut(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return DestOut(backdrop, source, <#=blender#>(backdrop, source));
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_Clear(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return Clear(backdrop, source, source);
        }             

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vector4 <#=blender#>_Xor(Vector4 backdrop, Vector4 source, float opacity)
        {
            opacity = opacity.Clamp(0, 1);
            source.W *= opacity;          

            return Xor(backdrop, source, source);
        }   

<# } #>


<# void GenerateGenericPixelBlender(string blender, string composer) { #>        

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TPixel <#=blender#>_<#=composer#><TPixel>(TPixel backdrop, TPixel source, float opacity)
            where TPixel : struct, IPixel<TPixel>
        {
            TPixel dest = default;
            dest.PackFromVector4(<#=blender#>_<#=composer#>(backdrop.ToVector4(),source.ToVector4(),opacity));
            return dest;
        }

<# } #>

        #region Blenders
<#

// GenerateVectorCompositor("Src",      "source",       "Vector4.Zero", "xform");
GenerateVectorCompositor("SrcAtop",     "Vector4.Zero", "backdrop",     "xform");
GenerateVectorCompositor("SrcOver",     "source",       "backdrop",     "xform");
// GenerateVectorCompositor("SrcIn",       "Vector4.Zero", "Vector4.Zero", "xform");
// GenerateVectorCompositor("SrcOut",      "source",       "Vector4.Zero", "Vector4.Zero");
GenerateVectorCompositor("Dest",     "Vector4.Zero", "backdrop",     "backdrop");
// GenerateVectorCompositor("DestAtop", "source",       "Vector4.Zero", "backdrop");
// GenerateVectorCompositor("DestOver", "source",       "backdrop",     "backdrop");
// GenerateVectorCompositor("DestIn",   "Vector4.Zero", "Vector4.Zero", "backdrop");
GenerateVectorCompositor("DestOut",  "Vector4.Zero", "backdrop",     "Vector4.Zero");
// GenerateVectorCompositor("Clear",    "Vector4.Zero", "Vector4.Zero", "Vector4.Zero");
GenerateVectorCompositor("Xor", "source", "backdrop", "Vector4.Zero");

string[] composers = new []{         
    "Src"      ,
    "SrcAtop"     ,
    "SrcOver"     ,
    "SrcIn"       ,
    "SrcOut"      ,
    "Dest"     ,
    "DestAtop" ,
    "DestOver" ,
    "DestIn"   ,
    "DestOut"  ,
    "Clear"    ,
    "Xor"      ,
};

string[] blenders = new []{         
    "Normal"      ,
    "Multiply"     ,
    "Add"     ,
    "Subtract"       ,
    "Screen"      ,
    "Darken"     ,
    "Lighten" ,
    "Overlay" ,
    "HardLight"
}; 

    foreach(var blender in blenders)
    {        
        GeneratePixelBlenders(blender);
        
        foreach(var composer in composers)
        {
            GenerateGenericPixelBlender(blender,composer);
        }
    }

#>

        #endregion
    }
}