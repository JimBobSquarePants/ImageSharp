// Copyright (c) Six Labors and contributors.
// Licensed under the Apache License, Version 2.0.

// <auto-generated />
using System;
using System.Numerics;
using System.Buffers;
using SixLabors.Memory;

namespace SixLabors.ImageSharp.PixelFormats.PixelBlenders
{
    /// <summary>
    /// Collection of Porter Duff alpha blending functions applying different composition models.
    /// </summary>
    /// <remarks>
    /// These functions are designed to be a general solution for all color cases,
    /// that is, they take in account the alpha value of both the backdrop
    /// and source, and there's no need to alpha-premultiply neither the backdrop
    /// nor the source.
    /// Note there are faster functions for when the backdrop color is known
    /// to be opaque
    /// </remarks>
    internal static class DefaultPixelBlenders<TPixel>
        where TPixel : struct, IPixel<TPixel>
    {

            internal class NormalSrc : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalSrc Instance { get; } = new NormalSrc();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalSrc(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalSrc(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplySrc : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplySrc Instance { get; } = new MultiplySrc();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplySrc(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplySrc(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddSrc : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddSrc Instance { get; } = new AddSrc();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddSrc(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddSrc(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractSrc : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractSrc Instance { get; } = new SubtractSrc();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractSrc(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractSrc(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenSrc : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenSrc Instance { get; } = new ScreenSrc();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenSrc(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenSrc(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenSrc : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenSrc Instance { get; } = new DarkenSrc();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenSrc(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenSrc(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenSrc : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenSrc Instance { get; } = new LightenSrc();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenSrc(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenSrc(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlaySrc : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlaySrc Instance { get; } = new OverlaySrc();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlaySrc(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlaySrc(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightSrc : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightSrc Instance { get; } = new HardLightSrc();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightSrc(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightSrc(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class NormalSrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalSrcAtop Instance { get; } = new NormalSrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalSrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalSrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplySrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplySrcAtop Instance { get; } = new MultiplySrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplySrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplySrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddSrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddSrcAtop Instance { get; } = new AddSrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddSrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddSrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractSrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractSrcAtop Instance { get; } = new SubtractSrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractSrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractSrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenSrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenSrcAtop Instance { get; } = new ScreenSrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenSrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenSrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenSrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenSrcAtop Instance { get; } = new DarkenSrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenSrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenSrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenSrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenSrcAtop Instance { get; } = new LightenSrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenSrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenSrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlaySrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlaySrcAtop Instance { get; } = new OverlaySrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlaySrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlaySrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightSrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightSrcAtop Instance { get; } = new HardLightSrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightSrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightSrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class NormalSrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalSrcOver Instance { get; } = new NormalSrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalSrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalSrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplySrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplySrcOver Instance { get; } = new MultiplySrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplySrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplySrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddSrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddSrcOver Instance { get; } = new AddSrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddSrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddSrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractSrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractSrcOver Instance { get; } = new SubtractSrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractSrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractSrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenSrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenSrcOver Instance { get; } = new ScreenSrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenSrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenSrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenSrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenSrcOver Instance { get; } = new DarkenSrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenSrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenSrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenSrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenSrcOver Instance { get; } = new LightenSrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenSrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenSrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlaySrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlaySrcOver Instance { get; } = new OverlaySrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlaySrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlaySrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightSrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightSrcOver Instance { get; } = new HardLightSrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightSrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightSrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class NormalSrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalSrcIn Instance { get; } = new NormalSrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalSrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalSrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplySrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplySrcIn Instance { get; } = new MultiplySrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplySrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplySrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddSrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddSrcIn Instance { get; } = new AddSrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddSrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddSrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractSrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractSrcIn Instance { get; } = new SubtractSrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractSrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractSrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenSrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenSrcIn Instance { get; } = new ScreenSrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenSrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenSrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenSrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenSrcIn Instance { get; } = new DarkenSrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenSrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenSrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenSrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenSrcIn Instance { get; } = new LightenSrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenSrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenSrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlaySrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlaySrcIn Instance { get; } = new OverlaySrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlaySrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlaySrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightSrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightSrcIn Instance { get; } = new HardLightSrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightSrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightSrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class NormalSrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalSrcOut Instance { get; } = new NormalSrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalSrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalSrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplySrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplySrcOut Instance { get; } = new MultiplySrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplySrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplySrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddSrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddSrcOut Instance { get; } = new AddSrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddSrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddSrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractSrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractSrcOut Instance { get; } = new SubtractSrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractSrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractSrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenSrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenSrcOut Instance { get; } = new ScreenSrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenSrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenSrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenSrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenSrcOut Instance { get; } = new DarkenSrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenSrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenSrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenSrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenSrcOut Instance { get; } = new LightenSrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenSrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenSrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlaySrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlaySrcOut Instance { get; } = new OverlaySrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlaySrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlaySrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightSrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightSrcOut Instance { get; } = new HardLightSrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightSrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightSrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class NormalDest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalDest Instance { get; } = new NormalDest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalDest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalDest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplyDest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplyDest Instance { get; } = new MultiplyDest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplyDest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplyDest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddDest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddDest Instance { get; } = new AddDest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddDest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddDest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractDest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractDest Instance { get; } = new SubtractDest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractDest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractDest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenDest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenDest Instance { get; } = new ScreenDest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenDest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenDest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenDest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenDest Instance { get; } = new DarkenDest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenDest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenDest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenDest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenDest Instance { get; } = new LightenDest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenDest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenDest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlayDest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlayDest Instance { get; } = new OverlayDest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlayDest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlayDest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightDest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightDest Instance { get; } = new HardLightDest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightDest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightDest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class NormalDestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalDestAtop Instance { get; } = new NormalDestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalDestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalDestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplyDestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplyDestAtop Instance { get; } = new MultiplyDestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplyDestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplyDestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddDestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddDestAtop Instance { get; } = new AddDestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddDestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddDestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractDestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractDestAtop Instance { get; } = new SubtractDestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractDestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractDestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenDestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenDestAtop Instance { get; } = new ScreenDestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenDestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenDestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenDestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenDestAtop Instance { get; } = new DarkenDestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenDestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenDestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenDestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenDestAtop Instance { get; } = new LightenDestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenDestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenDestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlayDestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlayDestAtop Instance { get; } = new OverlayDestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlayDestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlayDestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightDestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightDestAtop Instance { get; } = new HardLightDestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightDestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightDestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class NormalDestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalDestOver Instance { get; } = new NormalDestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalDestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalDestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplyDestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplyDestOver Instance { get; } = new MultiplyDestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplyDestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplyDestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddDestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddDestOver Instance { get; } = new AddDestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddDestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddDestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractDestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractDestOver Instance { get; } = new SubtractDestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractDestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractDestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenDestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenDestOver Instance { get; } = new ScreenDestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenDestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenDestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenDestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenDestOver Instance { get; } = new DarkenDestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenDestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenDestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenDestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenDestOver Instance { get; } = new LightenDestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenDestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenDestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlayDestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlayDestOver Instance { get; } = new OverlayDestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlayDestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlayDestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightDestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightDestOver Instance { get; } = new HardLightDestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightDestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightDestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class NormalDestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalDestIn Instance { get; } = new NormalDestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalDestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalDestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplyDestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplyDestIn Instance { get; } = new MultiplyDestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplyDestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplyDestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddDestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddDestIn Instance { get; } = new AddDestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddDestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddDestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractDestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractDestIn Instance { get; } = new SubtractDestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractDestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractDestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenDestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenDestIn Instance { get; } = new ScreenDestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenDestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenDestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenDestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenDestIn Instance { get; } = new DarkenDestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenDestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenDestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenDestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenDestIn Instance { get; } = new LightenDestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenDestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenDestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlayDestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlayDestIn Instance { get; } = new OverlayDestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlayDestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlayDestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightDestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightDestIn Instance { get; } = new HardLightDestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightDestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightDestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class NormalDestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalDestOut Instance { get; } = new NormalDestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalDestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalDestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplyDestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplyDestOut Instance { get; } = new MultiplyDestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplyDestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplyDestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddDestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddDestOut Instance { get; } = new AddDestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddDestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddDestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractDestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractDestOut Instance { get; } = new SubtractDestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractDestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractDestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenDestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenDestOut Instance { get; } = new ScreenDestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenDestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenDestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenDestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenDestOut Instance { get; } = new DarkenDestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenDestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenDestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenDestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenDestOut Instance { get; } = new LightenDestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenDestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenDestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlayDestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlayDestOut Instance { get; } = new OverlayDestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlayDestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlayDestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightDestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightDestOut Instance { get; } = new HardLightDestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightDestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightDestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class NormalClear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalClear Instance { get; } = new NormalClear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalClear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalClear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplyClear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplyClear Instance { get; } = new MultiplyClear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplyClear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplyClear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddClear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddClear Instance { get; } = new AddClear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddClear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddClear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractClear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractClear Instance { get; } = new SubtractClear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractClear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractClear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenClear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenClear Instance { get; } = new ScreenClear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenClear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenClear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenClear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenClear Instance { get; } = new DarkenClear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenClear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenClear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenClear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenClear Instance { get; } = new LightenClear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenClear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenClear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlayClear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlayClear Instance { get; } = new OverlayClear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlayClear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlayClear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightClear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightClear Instance { get; } = new HardLightClear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightClear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightClear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class NormalXor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static NormalXor Instance { get; } = new NormalXor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.NormalXor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.NormalXor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class MultiplyXor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static MultiplyXor Instance { get; } = new MultiplyXor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.MultiplyXor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.MultiplyXor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class AddXor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static AddXor Instance { get; } = new AddXor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.AddXor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.AddXor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class SubtractXor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static SubtractXor Instance { get; } = new SubtractXor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.SubtractXor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.SubtractXor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class ScreenXor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static ScreenXor Instance { get; } = new ScreenXor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.ScreenXor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.ScreenXor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class DarkenXor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static DarkenXor Instance { get; } = new DarkenXor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.DarkenXor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.DarkenXor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class LightenXor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static LightenXor Instance { get; } = new LightenXor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.LightenXor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.LightenXor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class OverlayXor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static OverlayXor Instance { get; } = new OverlayXor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.OverlayXor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.OverlayXor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLightXor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLightXor Instance { get; } = new HardLightXor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLightXor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLightXor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

    }
}