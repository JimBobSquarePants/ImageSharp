// Copyright (c) Six Labors and contributors.
// Licensed under the Apache License, Version 2.0.

// <auto-generated />
using System;
using System.Numerics;
using System.Buffers;
using SixLabors.Memory;

namespace SixLabors.ImageSharp.PixelFormats.PixelBlenders
{
    /// <summary>
    /// Collection of Porter Duff alpha blending functions applying different composition models.
    /// </summary>
    /// <remarks>
    /// These functions are designed to be a general solution for all color cases,
    /// that is, they take in account the alpha value of both the backdrop
    /// and source, and there's no need to alpha-premultiply neither the backdrop
    /// nor the source.
    /// Note there are faster functions for when the backdrop color is known
    /// to be opaque
    /// </remarks>
    internal static class DefaultPixelBlenders<TPixel>
        where TPixel : struct, IPixel<TPixel>
    {

            internal class Normal_Src : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_Src Instance { get; } = new Normal_Src();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_Src(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_Src(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_Src : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_Src Instance { get; } = new Multiply_Src();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_Src(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_Src(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_Src : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_Src Instance { get; } = new Add_Src();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_Src(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_Src(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_Src : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_Src Instance { get; } = new Subtract_Src();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_Src(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_Src(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_Src : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_Src Instance { get; } = new Screen_Src();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_Src(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_Src(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_Src : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_Src Instance { get; } = new Darken_Src();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_Src(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_Src(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_Src : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_Src Instance { get; } = new Lighten_Src();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_Src(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_Src(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_Src : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_Src Instance { get; } = new Overlay_Src();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_Src(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_Src(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_Src : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_Src Instance { get; } = new HardLight_Src();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_Src(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_Src(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Normal_SrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_SrcAtop Instance { get; } = new Normal_SrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_SrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_SrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_SrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_SrcAtop Instance { get; } = new Multiply_SrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_SrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_SrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_SrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_SrcAtop Instance { get; } = new Add_SrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_SrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_SrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_SrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_SrcAtop Instance { get; } = new Subtract_SrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_SrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_SrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_SrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_SrcAtop Instance { get; } = new Screen_SrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_SrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_SrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_SrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_SrcAtop Instance { get; } = new Darken_SrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_SrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_SrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_SrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_SrcAtop Instance { get; } = new Lighten_SrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_SrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_SrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_SrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_SrcAtop Instance { get; } = new Overlay_SrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_SrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_SrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_SrcAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_SrcAtop Instance { get; } = new HardLight_SrcAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_SrcAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_SrcAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Normal_SrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_SrcOver Instance { get; } = new Normal_SrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_SrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_SrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_SrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_SrcOver Instance { get; } = new Multiply_SrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_SrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_SrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_SrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_SrcOver Instance { get; } = new Add_SrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_SrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_SrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_SrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_SrcOver Instance { get; } = new Subtract_SrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_SrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_SrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_SrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_SrcOver Instance { get; } = new Screen_SrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_SrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_SrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_SrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_SrcOver Instance { get; } = new Darken_SrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_SrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_SrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_SrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_SrcOver Instance { get; } = new Lighten_SrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_SrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_SrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_SrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_SrcOver Instance { get; } = new Overlay_SrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_SrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_SrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_SrcOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_SrcOver Instance { get; } = new HardLight_SrcOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_SrcOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_SrcOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Normal_SrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_SrcIn Instance { get; } = new Normal_SrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_SrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_SrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_SrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_SrcIn Instance { get; } = new Multiply_SrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_SrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_SrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_SrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_SrcIn Instance { get; } = new Add_SrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_SrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_SrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_SrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_SrcIn Instance { get; } = new Subtract_SrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_SrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_SrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_SrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_SrcIn Instance { get; } = new Screen_SrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_SrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_SrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_SrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_SrcIn Instance { get; } = new Darken_SrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_SrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_SrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_SrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_SrcIn Instance { get; } = new Lighten_SrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_SrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_SrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_SrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_SrcIn Instance { get; } = new Overlay_SrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_SrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_SrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_SrcIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_SrcIn Instance { get; } = new HardLight_SrcIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_SrcIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_SrcIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Normal_SrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_SrcOut Instance { get; } = new Normal_SrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_SrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_SrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_SrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_SrcOut Instance { get; } = new Multiply_SrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_SrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_SrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_SrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_SrcOut Instance { get; } = new Add_SrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_SrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_SrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_SrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_SrcOut Instance { get; } = new Subtract_SrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_SrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_SrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_SrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_SrcOut Instance { get; } = new Screen_SrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_SrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_SrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_SrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_SrcOut Instance { get; } = new Darken_SrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_SrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_SrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_SrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_SrcOut Instance { get; } = new Lighten_SrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_SrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_SrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_SrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_SrcOut Instance { get; } = new Overlay_SrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_SrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_SrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_SrcOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_SrcOut Instance { get; } = new HardLight_SrcOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_SrcOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_SrcOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Normal_Dest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_Dest Instance { get; } = new Normal_Dest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_Dest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_Dest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_Dest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_Dest Instance { get; } = new Multiply_Dest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_Dest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_Dest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_Dest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_Dest Instance { get; } = new Add_Dest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_Dest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_Dest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_Dest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_Dest Instance { get; } = new Subtract_Dest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_Dest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_Dest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_Dest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_Dest Instance { get; } = new Screen_Dest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_Dest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_Dest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_Dest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_Dest Instance { get; } = new Darken_Dest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_Dest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_Dest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_Dest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_Dest Instance { get; } = new Lighten_Dest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_Dest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_Dest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_Dest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_Dest Instance { get; } = new Overlay_Dest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_Dest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_Dest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_Dest : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_Dest Instance { get; } = new HardLight_Dest();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_Dest(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_Dest(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Normal_DestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_DestAtop Instance { get; } = new Normal_DestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_DestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_DestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_DestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_DestAtop Instance { get; } = new Multiply_DestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_DestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_DestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_DestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_DestAtop Instance { get; } = new Add_DestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_DestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_DestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_DestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_DestAtop Instance { get; } = new Subtract_DestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_DestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_DestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_DestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_DestAtop Instance { get; } = new Screen_DestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_DestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_DestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_DestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_DestAtop Instance { get; } = new Darken_DestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_DestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_DestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_DestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_DestAtop Instance { get; } = new Lighten_DestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_DestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_DestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_DestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_DestAtop Instance { get; } = new Overlay_DestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_DestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_DestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_DestAtop : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_DestAtop Instance { get; } = new HardLight_DestAtop();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_DestAtop(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_DestAtop(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Normal_DestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_DestOver Instance { get; } = new Normal_DestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_DestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_DestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_DestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_DestOver Instance { get; } = new Multiply_DestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_DestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_DestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_DestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_DestOver Instance { get; } = new Add_DestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_DestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_DestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_DestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_DestOver Instance { get; } = new Subtract_DestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_DestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_DestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_DestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_DestOver Instance { get; } = new Screen_DestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_DestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_DestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_DestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_DestOver Instance { get; } = new Darken_DestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_DestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_DestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_DestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_DestOver Instance { get; } = new Lighten_DestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_DestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_DestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_DestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_DestOver Instance { get; } = new Overlay_DestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_DestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_DestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_DestOver : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_DestOver Instance { get; } = new HardLight_DestOver();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_DestOver(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_DestOver(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Normal_DestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_DestIn Instance { get; } = new Normal_DestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_DestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_DestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_DestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_DestIn Instance { get; } = new Multiply_DestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_DestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_DestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_DestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_DestIn Instance { get; } = new Add_DestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_DestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_DestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_DestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_DestIn Instance { get; } = new Subtract_DestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_DestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_DestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_DestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_DestIn Instance { get; } = new Screen_DestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_DestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_DestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_DestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_DestIn Instance { get; } = new Darken_DestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_DestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_DestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_DestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_DestIn Instance { get; } = new Lighten_DestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_DestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_DestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_DestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_DestIn Instance { get; } = new Overlay_DestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_DestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_DestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_DestIn : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_DestIn Instance { get; } = new HardLight_DestIn();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_DestIn(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_DestIn(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Normal_DestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_DestOut Instance { get; } = new Normal_DestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_DestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_DestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_DestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_DestOut Instance { get; } = new Multiply_DestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_DestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_DestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_DestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_DestOut Instance { get; } = new Add_DestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_DestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_DestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_DestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_DestOut Instance { get; } = new Subtract_DestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_DestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_DestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_DestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_DestOut Instance { get; } = new Screen_DestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_DestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_DestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_DestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_DestOut Instance { get; } = new Darken_DestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_DestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_DestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_DestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_DestOut Instance { get; } = new Lighten_DestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_DestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_DestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_DestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_DestOut Instance { get; } = new Overlay_DestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_DestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_DestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_DestOut : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_DestOut Instance { get; } = new HardLight_DestOut();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_DestOut(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_DestOut(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Normal_Clear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_Clear Instance { get; } = new Normal_Clear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_Clear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_Clear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_Clear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_Clear Instance { get; } = new Multiply_Clear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_Clear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_Clear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_Clear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_Clear Instance { get; } = new Add_Clear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_Clear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_Clear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_Clear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_Clear Instance { get; } = new Subtract_Clear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_Clear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_Clear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_Clear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_Clear Instance { get; } = new Screen_Clear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_Clear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_Clear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_Clear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_Clear Instance { get; } = new Darken_Clear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_Clear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_Clear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_Clear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_Clear Instance { get; } = new Lighten_Clear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_Clear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_Clear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_Clear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_Clear Instance { get; } = new Overlay_Clear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_Clear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_Clear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_Clear : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_Clear Instance { get; } = new HardLight_Clear();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_Clear(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_Clear(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Normal_Xor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Normal_Xor Instance { get; } = new Normal_Xor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Normal_Xor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Normal_Xor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Multiply_Xor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Multiply_Xor Instance { get; } = new Multiply_Xor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Multiply_Xor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Multiply_Xor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Add_Xor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Add_Xor Instance { get; } = new Add_Xor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Add_Xor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Add_Xor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Subtract_Xor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Subtract_Xor Instance { get; } = new Subtract_Xor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Subtract_Xor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Subtract_Xor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Screen_Xor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Screen_Xor Instance { get; } = new Screen_Xor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Screen_Xor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Screen_Xor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Darken_Xor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Darken_Xor Instance { get; } = new Darken_Xor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Darken_Xor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Darken_Xor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Lighten_Xor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Lighten_Xor Instance { get; } = new Lighten_Xor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Lighten_Xor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Lighten_Xor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class Overlay_Xor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static Overlay_Xor Instance { get; } = new Overlay_Xor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.Overlay_Xor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.Overlay_Xor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

            internal class HardLight_Xor : PixelBlender<TPixel>
            {
                /// <summary>
                /// Gets the static instance of this blender.
                /// </summary>
                public static HardLight_Xor Instance { get; } = new HardLight_Xor();

                /// <inheritdoc />
                public override TPixel Blend(TPixel background, TPixel source, float amount)
                {
                    return PorterDuffFunctions.HardLight_Xor(background, source, amount);
                }

                /// <inheritdoc />
                public override void Blend(MemoryAllocator memoryManager, Span<TPixel> destination, Span<TPixel> background, Span<TPixel> source, Span<float> amount)
                {
                    Guard.MustBeGreaterThanOrEqualTo(background.Length, destination.Length, nameof(background.Length));
                    Guard.MustBeGreaterThanOrEqualTo(source.Length, destination.Length, nameof(source.Length));
                    Guard.MustBeGreaterThanOrEqualTo(amount.Length, destination.Length, nameof(amount.Length));

                    using (IMemoryOwner<Vector4> buffer = memoryManager.Allocate<Vector4>(destination.Length * 3))
                    {
                        Span<Vector4> destinationSpan = buffer.Slice(0, destination.Length);
                        Span<Vector4> backgroundSpan = buffer.Slice(destination.Length, destination.Length);
                        Span<Vector4> sourceSpan = buffer.Slice(destination.Length * 2, destination.Length);

                        PixelOperations<TPixel>.Instance.ToVector4(background, backgroundSpan, destination.Length);
                        PixelOperations<TPixel>.Instance.ToVector4(source, sourceSpan, destination.Length);

                        for (int i = 0; i < destination.Length; i++)
                        {
                            destinationSpan[i] = PorterDuffFunctions.HardLight_Xor(backgroundSpan[i], sourceSpan[i], amount[i]);
                        }

                        PixelOperations<TPixel>.Instance.PackFromVector4(destinationSpan, destination, destination.Length);
                    }
                }
            }

    }
}